<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="MemoryCache is a cache for the transaction execution which delays writes to the database until transaction results are certified (i.e. they appear in a certified checkpoint, or an effects cert is observed by a fullnode). The cache also stores committed data in memory in order to serve future reads without hitting the database."><title>sui_core::execution_cache::writeback_cache - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="sui_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../sui_core/index.html">sui_core</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module writeback_cache</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section><h2><a href="../index.html">In sui_core::execution_cache</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">sui_core</a>::<wbr><a href="../index.html">execution_cache</a>::<wbr><a class="mod" href="#">writeback_cache</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/sui_core/execution_cache/writeback_cache.rs.html#4-1989">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>MemoryCache is a cache for the transaction execution which delays writes to the database until
transaction results are certified (i.e. they appear in a certified checkpoint, or an effects cert
is observed by a fullnode). The cache also stores committed data in memory in order to serve
future reads without hitting the database.</p>
<p>For storing uncommitted transaction outputs, we cannot evict the data at all until it is written
to disk. Committed data not only can be evicted, but it is also unbounded (imagine a stream of
transactions that keep splitting a coin into smaller coins).</p>
<p>We also want to be able to support negative cache hits (i.e. the case where we can determine an
object does not exist without hitting the database).</p>
<p>To achieve both of these goals, we split the cache data into two pieces, a dirty set and a cached
set. The dirty set has no automatic evictions, data is only removed after being committed. The
cached set is in a bounded-sized cache with automatic evictions. In order to support negative
cache hits, we treat the two halves of the cache as FIFO queue. Newly written (dirty) versions are
inserted to one end of the dirty queue. As versions are committed to disk, they are
removed from the other end of the dirty queue and inserted into the cache queue. The cache queue
is truncated if it exceeds its maximum size, by removing all but the N newest versions.</p>
<p>This gives us the property that the sequence of versions in the dirty and cached queues are the
most recent versions of the object, i.e. there can be no “gaps”. This allows for the following:</p>
<ul>
<li>Negative cache hits: If the queried version is not in memory, but is higher than the smallest
version in the cached queue, it does not exist in the db either.</li>
<li>Bounded reads: When reading the most recent version that is &lt;= some version bound, we can
correctly satisfy this query from the cache, or determine that we must go to the db.</li>
</ul>
<p>Note that at any time, either or both the dirty or the cached queue may be non-existent. There may be no
dirty versions of the objects, in which case there will be no dirty queue. And, the cached queue
may be evicted from the cache, in which case there will be no cached queue. Because only the cached
queue can be evicted (the dirty queue can only become empty by moving versions from it to the cached
queue), the “highest versions” property still holds in all cases.</p>
<p>The above design is used for both objects and markers.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.WritebackCache.html" title="struct sui_core::execution_cache::writeback_cache::WritebackCache">WritebackCache</a></div></li></ul></section></div></main></body></html>